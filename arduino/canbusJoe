//arduino leonardo
#include <SPI.h>
#include <mcp_can.h>

long unsigned int rx_id;   //CAN definitions
unsigned long rcvTime;
unsigned char len = 0;
unsigned char buf[8];
long unsigned int tx_send_1 = 0x1BEEF014;
unsigned char send_1_buf[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

const int SPI_CS_PIN = 11;
MCP_CAN CAN(SPI_CS_PIN);

#define io_1 A0 //closest CAN
#define io_2 A1
#define io_3 A2
#define io_4 A3

#define end_1_pin A0
#define end_2_pin A1

int jp1 = 30;
int jp2 = 4;
int jp3 = 12;

int v1 = A10;
int v2 = A4;
int v3 = A5;
int v4 = A7;

float resistors[8] = {10, 10, 10, 10, 10, 10, 10, 10}; //Resistance in kOhm used for voltage measurement
float voltage = 69.9;

int STOP = 17;

void transmiter() {
  char* int_char_array = (void*)(&voltage);
  send_1_buf[0] = int_char_array[0];
  send_1_buf[1] = int_char_array[1];
  send_1_buf[2] = int_char_array[2];
  send_1_buf[3] = int_char_array[3];
  send_1_buf[4] = digitalRead(end_1_pin);
  send_1_buf[5] = digitalRead(end_2_pin);
  CAN.sendMsgBuf(tx_send_1, 1, 8, send_1_buf);
}

unsigned int desired_gripper_positon = 0;

void receiver() {
//  Serial.println("WHATHHH");
  CAN.readMsgBuf(&len, buf);    // read data,  len: data length, buf: data buf
  rx_id = CAN.getCanId();
//  Serial.println("cunt");
  switch (rx_id) {
    case 0x1BEEF001: //emergency stop

      break;
    case 0x1BEEF002: //reset

      break;
    case 0x1BEEF015:
      char* int_char_array = (char*)(void*)(&desired_gripper_positon);
      int_char_array[0] = buf[0];
      int_char_array[1] = buf[1];
      Serial.println(desired_gripper_positon);
      break;
    default:
      break;
  }
}

void setup()
{
  Serial.begin(115200);
  while(!Serial);
  pinMode(SPI_CS_PIN, OUTPUT);
  digitalWrite(SPI_CS_PIN, LOW);

  while (CAN_OK != CAN.begin(CAN_250KBPS))
  {
    delay(200);
  }
  

  pinMode(end_1_pin, INPUT);
  pinMode(end_2_pin, INPUT);
}

void loop() {
  transmiter();
  delay(1000);
  if (CAN_MSGAVAIL == CAN.checkReceive()) {
    receiver();
  }
}

float mapfloat(float x, float in_min, float in_max, float out_min, float out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}


float getVoltage() {  //Function to read voltage from op amp, assuming that the order of outputs are configured so that they decrease in accuracy but increase in maximum voltage
  float v = 0;
  int useV = v1;
  float ratio[2] = {resistors[0], resistors[1]};
  float scale;
  if (analogRead(v1) >= 920) {
    useV = v2;
    ratio[0] = resistors[2];
    ratio[1] = resistors[3];
  } else if (analogRead(v2) >= 920) {
    useV = v3;
    ratio[0] = resistors[4];
    ratio[1] = resistors[5];
  } else if (analogRead(v3) >= 920) {
    useV = v4;
    ratio[0] = resistors[6];
    ratio[1] = resistors[7];
  }
  scale = (ratio[0] + ratio[0]) / ratio[1];

  v = mapfloat(analogRead(useV), 0, 1023, 0, 5) * scale;
  return (v);

}
