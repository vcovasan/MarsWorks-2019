#include "SPI.h"
#include "LoRa.h"

const byte numChars = 32;
char receivedChars[numChars];

boolean newData = false;

void SetupCommunication();

// Rover Manual Drive Commands
#define COMMAND_WHEELS 0x10
#define ROVER_TURN_LEFT 0x11
#define ROVER_TURN_RIGHT 0x12
#define ROVER_FORWARD 0x13
#define ROVER_REVERSE 0x13
#define ROVER_STOP 0x14

// Rover Box State
#define COMMAND_BOX 0x15


// Rover Arm Positions
#define COMMAND_ARM 0x20
#define SERVO_1 0x21
#define SERVO_2 0x22
#define ACTUATOR_1 0x23
#define ACTUATOR_2 0x24




// Rover Autonomous Navigation Commands
#define COMMAND_POSITION 0x30
#define COMMAND_AUTONOMOUS_MODE 0x40
#define COMMAND_MANUAL_MODE 0x50

// Extra defines
#define ROVER_STATE 0x60
#define SOIL_DATA 0x70

#define EMPTY 0



void setup() {
  Serial.begin(9600); // set the baud rate
  while (!Serial);
  SetupCommunication();
  Serial.print("Ready"); // print "Ready" once
}

void loop() {

  uint8_t packetSize = 0;



  char roverMode = ' ';
  char wheel = ' ';
  char joint = ' ';
  if (Serial.available()) {
    recvWithStartEndMarkers();
    // only send data back if data has been sent
    char roverMode = Serial.read();// read the incoming data
    sendRoverMode(roverMode); //
      
    // input 1 mode
//    if (roverMode == "w") {
//      while (Serial.read() != 'q') { // quit statement
//        delay(100);
//        char dir;
//        dir = Serial.read(); // input 2
//        if (dir == "f") {
//          char velocity = Serial.read(); // input 3
//          sendRoverWheelCommand(dir, velocity);
//        }
//        if (dir == "b") {
//          char velocity = Serial.read(); // input 3
//          sendRoverWheelCommand(dir, velocity);
//        }
//        if (dir == "l") {
//          char velocity = Serial.read(); // input 3
//          sendRoverWheelCommand(dir, velocity);
//        }
//        if (dir == "r") {
//          char velocity = Serial.read(); // input 3
//          sendRoverWheelCommand(wheel, velocity);
//        }
//      }
//    }

    if (roverMode == "a") {
      delay(50);
      int joint1Increment = 0;
      int joint4Increment = 0;
      int joint5Increment = 0;

      while (Serial.read() != "q")
        joint1Increment = joint1Increment + Serial.read();
      //sendRoverArmPosition('1', joint1Increment);
      delay(100);
      char joint2pwm = Serial.read();
      // sendRoverArmPosition('2', joint2pwm);
      delay(100);
      char joint3pwm = Serial.read();
      // sendRoverArmPosition('3', joint3pwm);
      delay(100);
      joint4Increment = joint4Increment + Serial.read();
      // sendRoverArmPosition('4', joint4Increment);
      delay(100);
      joint5Increment = joint5Increment + Serial.read();
      sendRoverArmPosition('5', joint5Increment);
      delay(100);
      char gripPwm = Serial.read();
      sendRoverArmPosition('6', gripPwm);
      delay(100);
      char joints[6] = {joint1Increment, joint2pwm, joint3pwm, joint4Increment, joint5Increment, gripPwm};
      sendNewData(joints);
    }
    if (roverMode == "b") { // get box code
      char boxType;
      boxType = Serial.read();
      delay(50);
      if (boxType == "s") {
        char scientificBoxNumber;
        scientificBoxNumber = Serial.read();
        if (scientificBoxNumber == "1") {
          sendRoverBoxOpen(boxType, scientificBoxNumber);
        }
        if (scientificBoxNumber == "2") {
          sendRoverBoxOpen(boxType, scientificBoxNumber);
        }
        if (scientificBoxNumber == "3") {
          sendRoverBoxOpen(boxType, scientificBoxNumber);
        }
      }
      if (boxType == "c") {
        char containerBoxNumber;
        containerBoxNumber = Serial.read();
        if (containerBoxNumber == "1") {
          sendRoverBoxOpen(boxType, containerBoxNumber);
        }
        if (containerBoxNumber == "2") {
          sendRoverBoxOpen(boxType, containerBoxNumber);
        }
      }
    }
  }

  else {
    Serial.println('Serial not available');
  }
  delay(100); // delay for 1/10 of a second
}

void SetupCommunication() {
  // Set Parameters for LoRa Radio (Bandwidth, Power, Frequency, SPI)
  // Available Bandwidths are: 7.8E3, 10.4E3, 15.6E3, 20.8E3, 31.25E3, 41.7E3, 62.5E3, 125E3, and 250E3.

  Serial.println("Setting up LoRa Communication");
  LoRa.setSPIFrequency(1E6);
  if (!LoRa.begin(433E6)) {
    Serial.println("Starting LoRa failed!");
    while (1);
  }

  //LoRa.setTxPower(2); //2-17
  LoRa.setSpreadingFactor(7); //6-12
  LoRa.setCodingRate4(8); //5-8
  LoRa.setSignalBandwidth(31.25E3);

}


void DecodeLoraPacket(uint8_t packetSize) {

  uint8_t messageType = (uint8_t) LoRa.read();

  //if (messageType == DATA_PACKET) {  }

}

void sendRoverMode(char roverMode) {
  LoRa.beginPacket();
  LoRa.print(roverMode);
  LoRa.endPacket();

}

void sendRoverPosition(char pos_x, char pos_y) {
  LoRa.beginPacket();
  LoRa.print(COMMAND_POSITION);
  LoRa.print(pos_x);
  LoRa.print(pos_y);
  LoRa.endPacket();

}

void sendRoverWheelCommand(char wheelCommand, char wheelVelocity) {
  LoRa.beginPacket();
  LoRa.print(COMMAND_WHEELS);
  LoRa.print(wheelCommand);
  LoRa.print(wheelVelocity);
  LoRa.endPacket();
}

void sendRoverArmPosition(char servo, char position) {
  LoRa.beginPacket();
  LoRa.print(COMMAND_ARM);
  LoRa.print(servo);
  LoRa.print(position);
  LoRa.endPacket();
}

void sendRoverBoxOpen(char boxType, char boxNumber) {
  LoRa.beginPacket();
  LoRa.print(COMMAND_BOX);
  LoRa.print(boxType);
  LoRa.print(boxNumber);
  LoRa.endPacket();
}


void recvWithStartEndMarkers() {
  static boolean recvInProgress = false;
  static byte ndx = 0;
  char startMarker = '<';
  char endMarker = '>';
  char rc;

  while (Serial.available() > 0 && newData == false) {
    rc = Serial.read();

    if (recvInProgress == true) {
      if (rc != endMarker) {
        receivedChars[ndx] = rc;
        ndx++;
        if (ndx >= numChars) {
          ndx = numChars - 1;
        }
      }
      else {
        receivedChars[ndx] = '\0'; // terminate the string
        recvInProgress = false;
        ndx = 0;
        newData = true;
      }
    }

    else if (rc == startMarker) {
      recvInProgress = true;
    }
  }
  sendNewData(receivedChars);
}

char* extractCommandSequence() {
  static boolean recvInProgress = false;
  static byte ndx = 0;
  char startMarker = '0xFD';
  char endMarker = '0xFE';
  char rc;

  while (Serial.available() > 0 && newData == false) {
    rc = Serial.read();

    if (recvInProgress == true) {
      if (rc != endMarker) {
        receivedChars[ndx] = rc;
        ndx++;
        if (ndx >= numChars) {
          ndx = numChars - 1;
        }
      }
      else {
        receivedChars[ndx] = '\0'; // terminate the string
        recvInProgress = false;
        ndx = 0;
        newData = true;
      }
    }

    else if (rc == startMarker) {
      recvInProgress = true;
    }
  }
  sendNewData(receivedChars);
}

void sendNewData(char* receivedChars) {
  if (newData == true) {
    LoRa.beginPacket();
    

    LoRa.print(receivedChars[0]);
    LoRa.print(receivedChars[1]);
    LoRa.print(receivedChars[2]);
    LoRa.endPacket();

    newData = false;
  }
}
